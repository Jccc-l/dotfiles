return {
	"nvim-tree/nvim-tree.lua",
	config = function()
		-- disable netrw at the very start of your init.lua
		vim.g.loaded_netrw = 1
		vim.g.loaded_netrwPlugin = 1
		-- setup with some options
		require("nvim-tree").setup({})
		vim.notify=require("notify")
		vim.api.nvim_create_user_command("Bdelete", function(opts)
			local bufnr = opts.args ~= "" and tonumber(opts.args) or vim.api.nvim_get_current_buf()

			if not vim.api.nvim_buf_is_valid(bufnr) then
				vim.notify("Bdelete: Buffer does not exist.", vim.log.levels.WARN)
				return
			end

			-- 检查是否有未保存更改，且没有使用 ! 标志
			if vim.bo[bufnr].modified and not opts.bang then
				local buf_name = vim.api.nvim_buf_get_name(bufnr)
				local tail_name = vim.fn.fnamemodify(buf_name, ":t")
				vim.notify(
					string.format(
						"Buffer '%s' has unsaved changes. Save with :w or use :Bdelete! to force close.",
						tail_name
					),
					vim.log.levels.WARN
				)
				return
			end

			local winnr = vim.fn.bufwinnr(bufnr)
			if winnr == vim.fn.winnr() then
				local success, _ = pcall(function()
					vim.cmd("bp")
				end)
				if not success then
					success, _ = pcall(function()
						vim.cmd("bn")
					end)
					if not success then
						vim.notify("No other buffer to switch to.", vim.log.levels.WARN)
						return
					end
				end
				pcall(vim.api.nvim_buf_delete, bufnr, { force = true })
			else
				pcall(vim.api.nvim_buf_delete, bufnr, { force = true })
			end
		end, {
			nargs = "?",
			bang = true, -- 支持 ! 标志
			desc = "Delete buffer; warns if modified unless ! is used",
		})

		---------------
		--Smart Close--
		---------------

		-- 工具函数：判断 buffer 是否为 NvimTree
		local function is_nvim_tree_buffer(buf)
			local ft = vim.bo[buf].filetype
			local name = vim.api.nvim_buf_get_name(buf)
			return ft == "NvimTree" or name:match("NvimTree") ~= nil
		end

		-- 获取所有非 NvimTree 的文件窗口
		local function get_file_windows()
			local file_windows = {}
			for _, win in ipairs(vim.api.nvim_list_wins()) do
				local buf = vim.api.nvim_win_get_buf(win)
				if vim.api.nvim_buf_is_valid(buf) and vim.api.nvim_buf_is_loaded(buf) then
					if not is_nvim_tree_buffer(buf) then
						table.insert(file_windows, win)
					end
				end
			end
			return file_windows
		end

		-- 检查是否有任何未保存的修改（包括 no name buffer）
		local function has_unsaved_changes()
			for _, buf in ipairs(vim.api.nvim_list_bufs()) do
				if vim.api.nvim_buf_is_valid(buf) and vim.api.nvim_buf_is_loaded(buf) then
					if not is_nvim_tree_buffer(buf) and vim.bo[buf].modified then
						return true
					end
				end
			end
			return false
		end

		-- 获取所有未保存的缓冲区名称（用于显示警告信息）
		local function get_unsaved_buffers_info()
			local unsaved = {}
			for _, buf in ipairs(vim.api.nvim_list_bufs()) do
				if vim.api.nvim_buf_is_valid(buf) and vim.api.nvim_buf_is_loaded(buf) then
					if not is_nvim_tree_buffer(buf) and vim.bo[buf].modified then
						local name = vim.api.nvim_buf_get_name(buf)
						local display_name = name == "" and "[No Name]" or vim.fn.fnamemodify(name, ":t")
						table.insert(unsaved, display_name)
					end
				end
			end
			return unsaved
		end

		-- 自定义命令：Close（安全关闭）
		vim.api.nvim_create_user_command("Close", function(opts)
			local bang = opts.bang
			local file_windows = get_file_windows()
			local file_window_count = #file_windows

			if bang then
				-- Close! 强制关闭逻辑
				if file_window_count > 1 then
					-- 多个文件窗口：关闭当前窗口
					vim.cmd("close!")
				else
					-- 单个文件窗口或无文件窗口：强制退出 Neovim
					vim.cmd("qa!")
				end
				return
			end

			-- Close 安全关闭逻辑
			if file_window_count > 1 then
				-- 多个文件窗口：关闭当前窗口
				vim.cmd("close")
			else
				-- 单个文件窗口或无文件窗口
				if has_unsaved_changes() then
					-- 有未保存的修改：发出警告
					local unsaved_buffers = get_unsaved_buffers_info()
					vim.notify(
						("Failed to quit: No write since last change for buffer:\t%s"):format(
							table.concat(unsaved_buffers, "\t")
						),
						vim.log.levels.WARN,
						{ title = "Close" }
					)
				else
					-- 所有 buffer 都已保存：退出 Neovim
					vim.cmd("qa")
				end
			end
		end, {
			nargs = 0,
			bang = true,
			desc = "Close window or quit Neovim safely. Use Close! to force close.",
		})

		vim.api.nvim_create_user_command("C", function(opts)
			if opts.bang then
				vim.cmd("Close!")
			else
				vim.cmd("Close")
			end
		end, {
			nargs = 0,
			bang = true,
			desc = "Alias for Close command",
		})

		require("which-key").add({
			{
				"<leader>q",
				function()
					vim.cmd("Close")
				end,
			},
			{
				"<leader>Q",
				function()
					vim.cmd("Close!")
				end,
			},
			{
				"<leader>B",
				function()
					vim.cmd("Bdelete!")
				end,
			},
		})
	end,
	lazy = false,
}
